<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>浅谈 node-jvm(1) | MartinDelophy</title><meta name="viewport" content="width=640"/><link rel="stylesheet" href="/style.css"/></head><body><header><section><a class="nav-home" href="/">MartinDelophy</a><nav><a href="/blog">技术博客</a><a href="/#">个人简历</a><a href="/#">图标3</a><a href="/#" class="active">图标4</a><a href="/#">图标5</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="请搜索..."/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>浅谈 node-jvm(1)</h1><p>2018-5-14 by MartinDelophy</p><hr/><div><p>前不久，在github不小心看到了一个node-jvm 不由得惊叹，node竟然也能写出jvm，故clone了一波来看看到底是何方神圣。
地址:<a href="https://github.com/YaroslavGaponov/node-jvm">https://github.com/YaroslavGaponov/node-jvm</a></p><p>首先那肯定是看一下官方案例的，官方主要是用fibonacci.js 来new了一个jvm，然后设定日志等级，载入class文件，设定异步事件，就开始执行了。感觉很ok</p><p>那么，我们先看看它jvm地方的源码吧，首先，看到的是这句话,无用的代码暂时省略</p><pre class="prism language-undefined"><span class="keyword">var</span> JVM <span class="operator">=</span> module<span class="punctuation">.</span>exports <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">if</span> <span class="punctuation">(</span><span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="class-name">JVM</span><span class="punctuation">)</span> <span class="punctuation">{</span>
        JVM<span class="punctuation">.</span>super_<span class="punctuation">.</span><span class="function">call</span><span class="punctuation">(</span><span class="keyword">this</span><span class="punctuation">)</span><span class="punctuation">;</span>
        THREADS<span class="punctuation">.</span><span class="function">add</span><span class="punctuation">(</span><span class="keyword">new</span> <span class="class-name">Thread</span><span class="punctuation">(</span><span class="string">&quot;main&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span>

        <span class="keyword">this</span><span class="punctuation">.</span>entryPoint <span class="operator">=</span> <span class="punctuation">{</span>
            className<span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span>
            methodName<span class="punctuation">:</span> <span class="string">&quot;main&quot;</span>
        <span class="punctuation">}</span><span class="punctuation">;</span>
    <span class="punctuation">}</span> <span class="keyword">else</span> <span class="punctuation">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="class-name">JVM</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">;</span>
    <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>代码很直观，我们可以看到一开始，如果该对象是通过jvm new出来的对象就进行入 JVM.super_.call这句话中，如果不是则 new 一下返回。</p><p>这几个地方还是比较容易理解的，除了这句 JVM.super<em>.call，我翻遍了代码，但是却没有找到这个super</em> 方法,那么这个super_  方法是哪里来的呢？
幸运的是，另外一句话也同样引起了我的注意</p><pre class="prism language-undefined"><span class="keyword">var</span> util <span class="operator">=</span> <span class="function">require</span><span class="punctuation">(</span><span class="string">&quot;util&quot;</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="keyword">var</span> EE <span class="operator">=</span> <span class="function">require</span><span class="punctuation">(</span><span class="string">&quot;events&quot;</span><span class="punctuation">)</span><span class="punctuation">.</span>EventEmitter<span class="punctuation">;</span>
util<span class="punctuation">.</span><span class="function">inherits</span><span class="punctuation">(</span>JVM<span class="punctuation">,</span> EE<span class="punctuation">)</span><span class="punctuation">;</span></pre><p>util.inherits指的是将 require(&quot;events&quot;).EventEmitter 方法继承到JVM中,那么super_ 从哪里来的呢，我们还是不知道，通过 这篇blog的帮助(<a href="https://www.cnblogs.com/youlechang123/p/5602335.html),我们看到了一段代码">https://www.cnblogs.com/youlechang123/p/5602335.html),我们看到了一段代码</a></p><pre class="prism language-undefined">exports<span class="punctuation">.</span>inherits <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>ctor<span class="punctuation">,</span> superCtor<span class="punctuation">)</span> <span class="punctuation">{</span>
 ctor<span class="punctuation">.</span>super_ <span class="operator">=</span> superCtor<span class="punctuation">;</span>
 ctor<span class="punctuation">.</span>prototype <span class="operator">=</span> Object<span class="punctuation">.</span><span class="function">create</span><span class="punctuation">(</span>superCtor<span class="punctuation">.</span>prototype<span class="punctuation">,</span> <span class="punctuation">{</span>
 constructor<span class="punctuation">:</span> <span class="punctuation">{</span>
  value<span class="punctuation">:</span> ctor<span class="punctuation">,</span>
  enumerable<span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span>
  writable<span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span>
  configurable<span class="punctuation">:</span> <span class="keyword">true</span>
 <span class="punctuation">}</span>
 <span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span><span class="punctuation">;</span></pre><p>这下，我恍然大悟，原来JVM.super_ 不仅这样出来，而且其中存放的是 EventEmitter 这个函数,并且在prototype中存放了 EventEmitter的原型，也就是说JVM可以获得EventEmitter中的所有方法，这也就可以解释了为什么JVM new出之后可以设定异步事件。</p><p>node-jvm 是一个比较庞大的部分，今天先分析到这里，在下一章中我会告诉大家一个有效的工具。</p></div></div><div class="nav-docs"><div class="nav-docs-section"><h3>Subscribe</h3><a rel="home" type="application/rss+xml" href="/blog/rss.xml">RSS</a></div><div class="nav-docs-section"><h3>Recent Posts</h3><ul><li><a href="/blog/java-backengineering/">java 反向工程</a></li><li><a href="/blog/continous-publish/">持续发布项目</a></li><li><a href="/blog/model-engine/">java script 模版引擎初探</a></li><li><a href="/blog/java-jvm2/">浅谈 node-jvm(2)</a></li><li>浅谈 node-jvm(1)</li><li><a href="/blog/java-annotation/">java 注解</a></li></ul></div></div></div></section><footer><section><a class="footer-home" href="/">MartinDelophy powered by graphql.org</a></section></footer></body></html>        <canvas id="live2d" width="260" height="300" className="live_2d" style="position:fixed;right:0px;bottom:0px" /><script src="/static/js/live2d.min.js"></script><!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>浅谈 node-jvm(1) | MartinDelophy</title><meta name="viewport" content="width=640"/><link rel="stylesheet" href="/style.css"/></head><body><header><section><a class="nav-home" href="/">MartinDelophy</a><nav><a href="/blog">技术博客</a><a href="/#">个人简历</a><a href="/#">图标3</a><a href="/#" class="active">图标4</a><a href="/#">图标5</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="请搜索..."/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>浅谈 node-jvm(1)</h1><p>2018-5-14 by MartinDelophy</p><hr/><div><p>前不久，在github不小心看到了一个node-jvm 不由得惊叹，node竟然也能写出jvm，故clone了一波来看看到底是何方神圣。
地址:<a href="https://github.com/YaroslavGaponov/node-jvm">https://github.com/YaroslavGaponov/node-jvm</a></p><p>首先那肯定是看一下官方案例的，官方主要是用fibonacci.js 来new了一个jvm，然后设定日志等级，载入class文件，设定异步事件，就开始执行了。感觉很ok</p><p>那么，我们先看看它jvm地方的源码吧，首先，看到的是这句话,无用的代码暂时省略</p><pre class="prism language-undefined"><span class="keyword">var</span> JVM <span class="operator">=</span> module<span class="punctuation">.</span>exports <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">if</span> <span class="punctuation">(</span><span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="class-name">JVM</span><span class="punctuation">)</span> <span class="punctuation">{</span>
        JVM<span class="punctuation">.</span>super_<span class="punctuation">.</span><span class="function">call</span><span class="punctuation">(</span><span class="keyword">this</span><span class="punctuation">)</span><span class="punctuation">;</span>
        THREADS<span class="punctuation">.</span><span class="function">add</span><span class="punctuation">(</span><span class="keyword">new</span> <span class="class-name">Thread</span><span class="punctuation">(</span><span class="string">&quot;main&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span>

        <span class="keyword">this</span><span class="punctuation">.</span>entryPoint <span class="operator">=</span> <span class="punctuation">{</span>
            className<span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span>
            methodName<span class="punctuation">:</span> <span class="string">&quot;main&quot;</span>
        <span class="punctuation">}</span><span class="punctuation">;</span>
    <span class="punctuation">}</span> <span class="keyword">else</span> <span class="punctuation">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="class-name">JVM</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">;</span>
    <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>代码很直观，我们可以看到一开始，如果该对象是通过jvm new出来的对象就进行入 JVM.super_.call这句话中，如果不是则 new 一下返回。</p><p>这几个地方还是比较容易理解的，除了这句 JVM.super<em>.call，我翻遍了代码，但是却没有找到这个super</em> 方法,那么这个super_  方法是哪里来的呢？
幸运的是，另外一句话也同样引起了我的注意</p><pre class="prism language-undefined"><span class="keyword">var</span> util <span class="operator">=</span> <span class="function">require</span><span class="punctuation">(</span><span class="string">&quot;util&quot;</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="keyword">var</span> EE <span class="operator">=</span> <span class="function">require</span><span class="punctuation">(</span><span class="string">&quot;events&quot;</span><span class="punctuation">)</span><span class="punctuation">.</span>EventEmitter<span class="punctuation">;</span>
util<span class="punctuation">.</span><span class="function">inherits</span><span class="punctuation">(</span>JVM<span class="punctuation">,</span> EE<span class="punctuation">)</span><span class="punctuation">;</span></pre><p>util.inherits指的是将 require(&quot;events&quot;).EventEmitter 方法继承到JVM中,那么super_ 从哪里来的呢，我们还是不知道，通过 这篇blog的帮助(<a href="https://www.cnblogs.com/youlechang123/p/5602335.html),我们看到了一段代码">https://www.cnblogs.com/youlechang123/p/5602335.html),我们看到了一段代码</a></p><pre class="prism language-undefined">exports<span class="punctuation">.</span>inherits <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>ctor<span class="punctuation">,</span> superCtor<span class="punctuation">)</span> <span class="punctuation">{</span>
 ctor<span class="punctuation">.</span>super_ <span class="operator">=</span> superCtor<span class="punctuation">;</span>
 ctor<span class="punctuation">.</span>prototype <span class="operator">=</span> Object<span class="punctuation">.</span><span class="function">create</span><span class="punctuation">(</span>superCtor<span class="punctuation">.</span>prototype<span class="punctuation">,</span> <span class="punctuation">{</span>
 constructor<span class="punctuation">:</span> <span class="punctuation">{</span>
  value<span class="punctuation">:</span> ctor<span class="punctuation">,</span>
  enumerable<span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span>
  writable<span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span>
  configurable<span class="punctuation">:</span> <span class="keyword">true</span>
 <span class="punctuation">}</span>
 <span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span><span class="punctuation">;</span></pre><p>这下，我恍然大悟，原来JVM.super_ 不仅这样出来，而且其中存放的是 EventEmitter 这个函数,并且在prototype中存放了 EventEmitter的原型，也就是说JVM可以获得EventEmitter中的所有方法，这也就可以解释了为什么JVM new出之后可以设定异步事件。</p><p>node-jvm 是一个比较庞大的部分，今天先分析到这里，在下一章中我会告诉大家一个有效的工具。</p></div></div><div class="nav-docs"><div class="nav-docs-section"><h3>Subscribe</h3><a rel="home" type="application/rss+xml" href="/blog/rss.xml">RSS</a></div><div class="nav-docs-section"><h3>Recent Posts</h3><ul><li><a href="/blog/java-backengineering/">java 反向工程</a></li><li><a href="/blog/continous-publish/">持续发布项目</a></li><li><a href="/blog/model-engine/">java script 模版引擎初探</a></li><li><a href="/blog/java-jvm2/">浅谈 node-jvm(2)</a></li><li>浅谈 node-jvm(1)</li><li><a href="/blog/java-annotation/">java 注解</a></li></ul></div></div></div></section><footer><section><a class="footer-home" href="/">MartinDelophy powered by graphql.org</a></section></footer></body></html><script>if (!this.readyState || this.readyState == "complete") { window.loadlive2d("live2d","/static/live2d-widget-model-shizuku/assets/shizuku.model.json") }</script>